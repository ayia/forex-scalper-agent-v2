"""\nMain Orchestrator - Forex Scalper Agent V2\n==========================================\nMain entry point that coordinates all modules.\n"""\nimport time\nimport json\nfrom typing import List, Dict\nfrom loguru import logger\nimport sys\n\nfrom config import ALL_PAIRS, RISK_PARAMS\nfrom data_fetcher import data_fetcher\nfrom universe_filter import universe_filter\nfrom trend_following import TrendFollowingStrategy\nfrom mean_reversion import MeanReversionStrategy\nfrom risk_calculator import risk_calculator\n\n# Configure logging\nlogger.remove()\nlogger.add(sys.stdout, level="INFO", format="<green>{time:HH:mm:ss}</green> | <level>{level}</level> | {message}")\nlogger.add("logs/agent.log", rotation="1 day", level="DEBUG")\n\n\nclass ForexScalperAgent:\n    """Main agent that orchestrates the scanning process."""\n    \n    def __init__(self):\n        self.strategies = [\n            TrendFollowingStrategy(),\n            MeanReversionStrategy()\n        ]\n        self.confidence_threshold = RISK_PARAMS["confidence_threshold"]\n    \n    def run_cycle(self) -> List[Dict]:\n        """Execute one scanning cycle."""\n        logger.info("="*50)\n        logger.info("Starting new scan cycle")\n        \n        # 1. Filter tradable universe\n        tradable_pairs = universe_filter.get_tradable_universe()\n        if not tradable_pairs:\n            logger.warning("No tradable pairs found")\n            return []\n        \n        signals = []\n        \n        # 2. Analyze each pair\n        for pair in tradable_pairs:\n            logger.info(f"Analyzing {pair}...")\n            \n            # Fetch multi-timeframe data\n            data = data_fetcher.get_multiple_timeframes(pair)\n            if not data or len(data) < 3:\n                continue\n            \n            # 3. Run all strategies\n            for strategy in self.strategies:\n                try:\n                    signal = strategy.analyze(\n                        data_m1=data.get("m1"),\n                        data_m5=data.get("m5"),\n                        data_m15=data.get("m15"),\n                        data_h1=data.get("h1")\n                    )\n                    \n                    if signal and signal.confidence >= self.confidence_threshold:\n                        # 4. Calculate risk parameters\n                        execution_plan = risk_calculator.prepare_execution(\n                            signal, data.get("m5"), pair\n                        )\n                        \n                        if execution_plan:\n                            signals.append(execution_plan)\n                            logger.success(f"SIGNAL: {pair} {signal.signal.value} (Score: {signal.confidence})")\n                            print(json.dumps(execution_plan, indent=2, default=str))\n                            \n                except Exception as e:\n                    logger.error(f"Strategy {strategy.name} error on {pair}: {e}")\n        \n        logger.info(f"Cycle complete. Found {len(signals)} signals.")\n        return signals\n    \n    def run(self, interval_seconds: int = 60):\n        """Run the agent continuously."""\n        logger.info("Forex Scalper Agent V2 starting...")\n        logger.info(f"Monitoring {len(ALL_PAIRS)} pairs")\n        logger.info(f"Strategies: {[s.name for s in self.strategies]}")\n        logger.info(f"Scan interval: {interval_seconds}s")\n        \n        while True:\n            try:\n                self.run_cycle()\n                logger.info(f"Sleeping {interval_seconds}s until next cycle...")\n                time.sleep(interval_seconds)\n            except KeyboardInterrupt:\n                logger.info("Agent stopped by user")\n                break\n            except Exception as e:\n                logger.error(f"Cycle error: {e}")\n                time.sleep(10)\n\n\nif __name__ == "__main__":\n    agent = ForexScalperAgent()\n    \n    # Single cycle for testing\n    if len(sys.argv) > 1 and sys.argv[1] == "--once":\n        agent.run_cycle()\n    else:\n        # Continuous mode\n        agent.run(interval_seconds=60)