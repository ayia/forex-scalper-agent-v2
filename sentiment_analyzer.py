"""\nSentiment Analyzer Module\n=========================\nAnalyzes news headlines for market sentiment using NLP keywords.\n"""\nimport requests\nfrom bs4 import BeautifulSoup\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\nfrom loguru import logger\n\n\nclass SentimentAnalyzer:\n    """\n    Analyzes forex news sentiment using keyword-based NLP.\n    """\n    \n    BULLISH_KEYWORDS = [\n        "surge", "rally", "hawkish", "strength", "breakout", "optimism",\n        "gains", "rises", "jumps", "soars", "bullish", "upbeat", "positive"\n    ]\n    \n    BEARISH_KEYWORDS = [\n        "plunge", "crash", "dovish", "weakness", "selloff", "fears",\n        "falls", "drops", "slumps", "bearish", "negative", "concerns", "risks"\n    ]\n    \n    def __init__(self):\n        self._cache = {}\n        self._cache_time = None\n        self._cache_duration = 300  # 5 minutes\n    \n    def scrape_recent_news(self, pair: str, hours: int = 2) -> List[str]:\n        """\n        Scrape recent news headlines for a currency pair.\n        \n        Args:\n            pair: Currency pair (e.g., 'EURUSD')\n            hours: Look back period in hours\n            \n        Returns:\n            List of headline strings\n        """\n        headlines = []\n        base = pair[:3]\n        quote = pair[3:]\n        \n        try:\n            # Try ForexLive (simplified scraping)\n            url = f"https://www.forexlive.com/search/?q={base}+{quote}"\n            headers = {"User-Agent": "Mozilla/5.0"}\n            response = requests.get(url, headers=headers, timeout=10)\n            \n            if response.status_code == 200:\n                soup = BeautifulSoup(response.text, "lxml")\n                for title in soup.find_all(["h2", "h3"], limit=10):\n                    text = title.get_text(strip=True)\n                    if text and len(text) > 10:\n                        headlines.append(text.lower())\n            \n            logger.debug(f"Scraped {len(headlines)} headlines for {pair}")\n        except Exception as e:\n            logger.error(f"News scraping error for {pair}: {e}")\n        \n        return headlines\n    \n    def analyze_sentiment(self, headlines: List[str]) -> int:\n        """\n        Analyze sentiment from headlines.\n        \n        Args:\n            headlines: List of headline strings\n            \n        Returns:\n            Sentiment score from -10 (very bearish) to +10 (very bullish)\n        """\n        if not headlines:\n            return 0\n        \n        bullish_count = 0\n        bearish_count = 0\n        \n        for headline in headlines:\n            headline_lower = headline.lower()\n            for keyword in self.BULLISH_KEYWORDS:\n                if keyword in headline_lower:\n                    bullish_count += 1\n            for keyword in self.BEARISH_KEYWORDS:\n                if keyword in headline_lower:\n                    bearish_count += 1\n        \n        total = bullish_count + bearish_count\n        if total == 0:\n            return 0\n        \n        # Score from -10 to +10\n        score = ((bullish_count - bearish_count) / total) * 10\n        return int(max(-10, min(10, score)))\n    \n    def get_pair_sentiment(self, pair: str) -> Dict[str, any]:\n        """\n        Get sentiment analysis for a currency pair.\n        \n        Args:\n            pair: Currency pair\n            \n        Returns:\n            Dict with sentiment score and bias\n        """\n        # Check cache\n        now = datetime.utcnow()\n        cache_key = pair\n        if (cache_key in self._cache and self._cache_time and\n            (now - self._cache_time).seconds < self._cache_duration):\n            return self._cache[cache_key]\n        \n        headlines = self.scrape_recent_news(pair)\n        score = self.analyze_sentiment(headlines)\n        \n        if score >= 5:\n            bias = "strong_bullish"\n        elif score >= 2:\n            bias = "bullish"\n        elif score <= -5:\n            bias = "strong_bearish"\n        elif score <= -2:\n            bias = "bearish"\n        else:\n            bias = "neutral"\n        \n        result = {\n            "pair": pair,\n            "score": score,\n            "bias": bias,\n            "headlines_analyzed": len(headlines),\n            "timestamp": now.isoformat()\n        }\n        \n        self._cache[cache_key] = result\n        self._cache_time = now\n        \n        return result\n    \n    def is_contrarian_signal(self, pair: str, signal_direction: str) -> bool:\n        """\n        Check if signal is contrarian to current sentiment.\n        Contrarian signals have higher probability.\n        \n        Args:\n            pair: Currency pair\n            signal_direction: 'LONG' or 'SHORT'\n            \n        Returns:\n            True if signal is contrarian (good)\n        """\n        sentiment = self.get_pair_sentiment(pair)\n        score = sentiment["score"]\n        \n        # Contrarian: LONG when sentiment is bearish, SHORT when bullish\n        if signal_direction == "LONG" and score <= -3:\n            return True\n        if signal_direction == "SHORT" and score >= 3:\n            return True\n        return False\n\n\nsentiment_analyzer = SentimentAnalyzer()